<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>测试事件显示修复</title>
    <script>
        // 模拟TimeZoneUtils对象（时区转换功能已关闭）
        const TimeZoneUtils = {
            PDTtoCST: function(date) {
                // 时区转换功能已关闭，直接返回原始日期对象
                return new Date(date.getTime());
            },
            CSTtoPDT: function(date) {
                // 时区转换功能已关闭，直接返回原始日期对象
                return new Date(date.getTime());
            }
        };

        // 模拟convertToMilliseconds函数
        function convertToMilliseconds(value, unit) {
            const conversions = {
                'minutes': 60 * 1000,
                'hours': 60 * 60 * 1000,
                'days': 24 * 60 * 60 * 1000
            };
            return value * (conversions[unit] || 1000);
        }

        // 修复后的getNextOccurrence函数（只保留daily部分）
        function getNextOccurrence(task, nowCST) {
            // 创建nowPDT变量表示当前太平洋时间
            const nowPDT = TimeZoneUtils.CSTtoPDT(nowCST);

            if (task.recurrence.type === "daily") {
                // 每天重复
                // 获取所有时间点，如果没有则使用当前的startHour和startMinute
                const timePoints = task.recurrence.startTimes && task.recurrence.startTimes.length > 0 ? 
                    task.recurrence.startTimes.map(timeStr => {
                        const [h, m] = timeStr.split(':').map(Number);
                        return { hour: h, minute: m };
                    }) : [{ hour: 10, minute: 0 }];
                
                // 计算今天和明天的所有时间点组合
                const today = new Date(nowPDT);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                const candidates = [];
                
                // 检查今天的所有时间点
                for (const { hour, minute } of timePoints) {
                    const testDatePDT = new Date(today);
                    testDatePDT.setHours(hour, minute, 0, 0);
                    if (testDatePDT > nowPDT) {
                        candidates.push(testDatePDT);
                    }
                }
                
                // 如果今天没有找到合适的时间点，检查明天的所有时间点
                if (candidates.length === 0) {
                    for (const { hour, minute } of timePoints) {
                        const testDatePDT = new Date(tomorrow);
                        testDatePDT.setHours(hour, minute, 0, 0);
                        candidates.push(testDatePDT);
                    }
                }
                
                // 选择最近的时间点
                candidates.sort((a, b) => a - b);
                
                // 检查是否正在进行中（需要检查所有时间点，包括今天已经发生过的时间点）
                const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                
                // 首先检查今天的所有时间点（包括已经发生过的），看是否有正在进行中的事件
                for (const { hour, minute } of timePoints) {
                    const testDatePDT = new Date(today);
                    testDatePDT.setHours(hour, minute, 0, 0);
                    const candidateCST = TimeZoneUtils.PDTtoCST(testDatePDT);
                    if (candidateCST <= nowCST && nowCST < candidateCST.getTime() + durationMs) {
                        return {
                            startTime: candidateCST,
                            location: ""
                        };
                    }
                }
                
                // 如果没有正在进行中的事件，返回最近的时间点
                const nextTimeCST = TimeZoneUtils.PDTtoCST(candidates[0]);
                return {
                    startTime: nextTimeCST,
                    location: ""
                };
            }

            return null;
        }

        // 测试函数
        function testFix() {
            // 获取当前时间
            const nowCST = new Date();
            console.log('当前时间:', nowCST.toLocaleString());

            // 创建测试任务：每天10:00、14:00、18:00重复，持续3小时
            const testTask = {
                recurrence: {
                    type: "daily",
                    startTimes: ["10:00", "14:00", "18:00"],
                    duration: 3,
                    durationUnit: "hours"
                }
            };

            // 测试不同的当前时间
            const testTimes = [
                // 当前时间在10:00-13:00之间
                new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 11, 30, 0, 0),
                // 当前时间在14:00-17:00之间
                new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 15, 30, 0, 0),
                // 当前时间在18:00-21:00之间
                new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 19, 30, 0, 0),
                // 当前时间在所有时间点之后
                new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 22, 30, 0, 0)
            ];

            testTimes.forEach((testTime, index) => {
                console.log(`\n测试${index + 1} - 当前时间:`, testTime.toLocaleString());
                const result = getNextOccurrence(testTask, testTime);
                if (result) {
                    console.log('下一个事件时间:', result.startTime.toLocaleString());
                    console.log('事件状态:', 
                        (result.startTime <= testTime && testTime < new Date(result.startTime.getTime() + 3 * 60 * 60 * 1000)) ? 
                        '正在进行' : '即将开始');
                } else {
                    console.log('没有找到下一个事件');
                }
            });
        }

        // 页面加载完成后执行测试
        window.onload = function() {
            testFix();
        };
    </script>
</head>
<body>
    <h1>测试事件显示修复</h1>
    <p>请打开浏览器控制台查看测试结果。</p>
    <button onclick="testFix()">重新测试</button>
</body>
</html>