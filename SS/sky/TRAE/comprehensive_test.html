<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>全面测试事件显示修复</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .test-section {
            background-color: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #4CAF50;
            background-color: #f9f9f9;
        }
        .test-result.error {
            border-left-color: #f44336;
        }
        .test-result.warning {
            border-left-color: #ff9800;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #45a049;
        }
        input[type="time"] {
            margin: 5px;
            padding: 5px;
        }
        .test-scenario {
            margin: 15px 0;
            padding: 10px;
            background-color: #e8f5e9;
            border-radius: 4px;
        }
    </style>
    <script>
        // 模拟TimeZoneUtils对象（时区转换功能已关闭）
        const TimeZoneUtils = {
            PDTtoCST: function(date) {
                // 时区转换功能已关闭，直接返回原始日期对象
                return new Date(date.getTime());
            },
            CSTtoPDT: function(date) {
                // 时区转换功能已关闭，直接返回原始日期对象
                return new Date(date.getTime());
            }
        };

        // 模拟convertToMilliseconds函数
        function convertToMilliseconds(value, unit) {
            const conversions = {
                'minutes': 60 * 1000,
                'hours': 60 * 60 * 1000,
                'days': 24 * 60 * 60 * 1000
            };
            return value * (conversions[unit] || 1000);
        }

        // 模拟convertFromMilliseconds函数
        function convertFromMilliseconds(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                return { value: days, text: '天' };
            } else if (hours > 0) {
                return { value: hours, text: '小时' };
            } else if (minutes > 0) {
                return { value: minutes, text: '分钟' };
            } else {
                return { value: seconds, text: '秒' };
            }
        }

        // 模拟formatCountdown函数
        function formatCountdown(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);

            if (hours > 0) {
                return `${hours}小时${minutes % 60}分钟`;
            } else if (minutes > 0) {
                return `${minutes}分钟${seconds % 60}秒`;
            } else {
                return `${seconds}秒`;
            }
        }

        // 模拟createDefaultStatus函数
        function createDefaultStatus(nowCST, timeText, countdownMs, countdownText) {
            return {
                status: "future",
                timeText: timeText,
                countdownMs: countdownMs,
                countdownText: countdownText,
                minutes: Infinity,
                startTime: nowCST,
                endTime: nowCST,
                displayStartTime: nowCST,
                displayEndTime: nowCST,
                location: ""
            };
        }

        // 修复后的getNextOccurrence函数（只保留daily部分）
        function getNextOccurrence(task, nowCST) {
            // 创建nowPDT变量表示当前太平洋时间
            const nowPDT = TimeZoneUtils.CSTtoPDT(nowCST);

            if (task.recurrence.type === "daily") {
                // 每天重复
                // 获取所有时间点，如果没有则使用当前的startHour和startMinute
                const timePoints = task.recurrence.startTimes && task.recurrence.startTimes.length > 0 ? 
                    task.recurrence.startTimes.map(timeStr => {
                        const [h, m] = timeStr.split(':').map(Number);
                        return { hour: h, minute: m };
                    }) : [{ hour: 10, minute: 0 }];
                
                // 计算今天和明天的所有时间点组合
                const today = new Date(nowPDT);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                
                const candidates = [];
                
                // 检查今天的所有时间点
                for (const { hour, minute } of timePoints) {
                    const testDatePDT = new Date(today);
                    testDatePDT.setHours(hour, minute, 0, 0);
                    if (testDatePDT > nowPDT) {
                        candidates.push(testDatePDT);
                    }
                }
                
                // 如果今天没有找到合适的时间点，检查明天的所有时间点
                if (candidates.length === 0) {
                    for (const { hour, minute } of timePoints) {
                        const testDatePDT = new Date(tomorrow);
                        testDatePDT.setHours(hour, minute, 0, 0);
                        candidates.push(testDatePDT);
                    }
                }
                
                // 选择最近的时间点
                candidates.sort((a, b) => a - b);
                
                // 检查是否正在进行中（需要检查所有时间点，包括今天已经发生过的时间点）
                const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
                
                // 首先检查今天的所有时间点（包括已经发生过的），看是否有正在进行中的事件
                for (const { hour, minute } of timePoints) {
                    const testDatePDT = new Date(today);
                    testDatePDT.setHours(hour, minute, 0, 0);
                    const candidateCST = TimeZoneUtils.PDTtoCST(testDatePDT);
                    if (candidateCST <= nowCST && nowCST < candidateCST.getTime() + durationMs) {
                        return {
                            startTime: candidateCST,
                            location: ""
                        };
                    }
                }
                
                // 如果没有正在进行中的事件，返回最近的时间点
                const nextTimeCST = TimeZoneUtils.PDTtoCST(candidates[0]);
                return {
                    startTime: nextTimeCST,
                    location: ""
                };
            }

            return null;
        }

        // 模拟getTaskStatus函数
        function getTaskStatus(task, nowCST) {
            // 缓存重复计算的值
            const thresholdMs = convertToMilliseconds(task.displayThreshold, task.displayThresholdUnit);
            const durationMs = convertToMilliseconds(task.recurrence.duration, task.recurrence.durationUnit);
            
            try {
                // 普通事件处理
                const nextOccurrence = getNextOccurrence(task, nowCST);
                if (!nextOccurrence || !nextOccurrence.startTime) {
                    return createDefaultStatus(nowCST, "未来事件", 0, "--");
                }
                
                const nextStartCST = nextOccurrence.startTime;
                const location = nextOccurrence.location || "";
                const endTimeCST = new Date(nextStartCST.getTime() + durationMs);
                const displayStartTimeCST = new Date(nextStartCST.getTime() - thresholdMs);
                
                const isInDisplayRange = nowCST >= displayStartTimeCST;
                const isOngoing = nowCST >= nextStartCST && nowCST < endTimeCST;
                const timeUntilStart = nextStartCST - nowCST;
                
                // 单次事件且已结束
                if (task.recurrence.type === "none" && nowCST > endTimeCST) {
                    return {
                        status: "completed",
                        timeText: "已完成",
                        countdownMs: 0,
                        countdownText: "已完成",
                        minutes: Infinity,
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                }
                
                if (isOngoing) {
                    const timeLeft = endTimeCST - nowCST;
                    return {
                        status: "ongoing",
                        timeText: `正在进行`,
                        countdownMs: timeLeft,
                        countdownText: formatCountdown(timeLeft),
                        minutes: Math.ceil(timeLeft / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                } else if (isInDisplayRange) {
                    const converted = convertFromMilliseconds(timeUntilStart);
                    return {
                        status: "upcoming",
                        timeText: `${converted.value}${converted.text}后开始`,
                        countdownMs: timeUntilStart,
                        countdownText: formatCountdown(timeUntilStart),
                        minutes: Math.ceil(timeUntilStart / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                } else {
                    const converted = convertFromMilliseconds(timeUntilStart);
                    return {
                        status: "future",
                        timeText: `${converted.value}${converted.text}后开始`,
                        countdownMs: timeUntilStart,
                        countdownText: formatCountdown(timeUntilStart),
                        minutes: Math.ceil(timeUntilStart / (1000 * 60)),
                        startTime: nextStartCST,
                        endTime: endTimeCST,
                        displayStartTime: displayStartTimeCST,
                        displayEndTime: endTimeCST,
                        location: location
                    };
                }
            } catch (e) {
                console.error('计算任务状态出错:', e);
                return createDefaultStatus(nowCST, "时间计算中", 0, "--");
            }
        }

        // 测试函数
        function runTests() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';

            // 创建测试任务：每天10:00、14:00、18:00重复，持续3小时
            const testTask = {
                displayThreshold: 2,
                displayThresholdUnit: "hours",
                recurrence: {
                    type: "daily",
                    startTimes: ["10:00", "14:00", "18:00"],
                    duration: 3,
                    durationUnit: "hours"
                }
            };

            // 获取当前时间
            const nowCST = new Date();
            const currentHour = nowCST.getHours();
            const currentMinute = nowCST.getMinutes();

            // 测试场景
            const testScenarios = [
                // 当前时间在10:00-13:00之间
                { name: "场景1：当前时间在10:00-13:00之间", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 11, 30, 0, 0) },
                // 当前时间在14:00-17:00之间
                { name: "场景2：当前时间在14:00-17:00之间", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 15, 30, 0, 0) },
                // 当前时间在18:00-21:00之间
                { name: "场景3：当前时间在18:00-21:00之间", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 19, 30, 0, 0) },
                // 当前时间在所有时间点之后
                { name: "场景4：当前时间在所有时间点之后", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 22, 30, 0, 0) },
                // 当前时间在10:00之前
                { name: "场景5：当前时间在10:00之前", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 9, 30, 0, 0) },
                // 当前时间在13:00-14:00之间
                { name: "场景6：当前时间在13:00-14:00之间", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 13, 30, 0, 0) },
                // 当前时间在17:00-18:00之间
                { name: "场景7：当前时间在17:00-18:00之间", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 17, 30, 0, 0) },
                // 当前时间在10:00整
                { name: "场景8：当前时间在10:00整", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 10, 0, 0, 0) },
                // 当前时间在13:00整（10:00开始的事件结束时间）
                { name: "场景9：当前时间在13:00整（10:00开始的事件结束时间）", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 13, 0, 0, 0) },
                // 当前时间在13:00过1秒（10:00开始的事件刚刚结束）
                { name: "场景10：当前时间在13:00过1秒（10:00开始的事件刚刚结束）", time: new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), 13, 0, 1, 0) }
            ];

            let allPassed = true;

            testScenarios.forEach((scenario, index) => {
                const result = getTaskStatus(testTask, scenario.time);
                const scenarioDiv = document.createElement('div');
                scenarioDiv.className = 'test-scenario';
                
                scenarioDiv.innerHTML = `<h3>${scenario.name}</h3>`;
                scenarioDiv.innerHTML += `<p>测试时间: ${scenario.time.toLocaleString()}</p>`;
                scenarioDiv.innerHTML += `<p>事件状态: ${result.status}</p>`;
                scenarioDiv.innerHTML += `<p>时间文本: ${result.timeText}</p>`;
                scenarioDiv.innerHTML += `<p>倒计时: ${result.countdownText}</p>`;
                scenarioDiv.innerHTML += `<p>开始时间: ${result.startTime.toLocaleString()}</p>`;
                scenarioDiv.innerHTML += `<p>结束时间: ${result.endTime.toLocaleString()}</p>`;

                // 检查预期状态
                let expectedStatus = "upcoming";
                let expectedStartTime = "";
                const testHour = scenario.time.getHours();
                const testMinute = scenario.time.getMinutes();

                if (testHour >= 10 && testHour < 13 || (testHour === 13 && testMinute === 0)) {
                    expectedStatus = "ongoing";
                    expectedStartTime = "10:00";
                } else if (testHour >= 14 && testHour < 17 || (testHour === 17 && testMinute === 0)) {
                    expectedStatus = "ongoing";
                    expectedStartTime = "14:00";
                } else if (testHour >= 18 && testHour < 21 || (testHour === 21 && testMinute === 0)) {
                    expectedStatus = "ongoing";
                    expectedStartTime = "18:00";
                } else if (testHour < 10) {
                    expectedStatus = "upcoming";
                    expectedStartTime = "10:00";
                } else if (testHour >= 13 && testHour < 14) {
                    expectedStatus = "upcoming";
                    expectedStartTime = "14:00";
                } else if (testHour >= 17 && testHour < 18) {
                    expectedStatus = "upcoming";
                    expectedStartTime = "18:00";
                } else {
                    // 21:00之后
                    expectedStatus = "upcoming";
                    expectedStartTime = "10:00";
                }

                // 验证结果
                const startTimeStr = result.startTime.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                const passed = result.status === expectedStatus && startTimeStr.includes(expectedStartTime);
                
                if (passed) {
                    scenarioDiv.innerHTML += `<p style="color: green; font-weight: bold;">✅ 测试通过！</p>`;
                } else {
                    scenarioDiv.innerHTML += `<p style="color: red; font-weight: bold;">❌ 测试失败！预期状态: ${expectedStatus}, 预期开始时间: ${expectedStartTime}</p>`;
                    allPassed = false;
                }

                resultsDiv.appendChild(scenarioDiv);
            });

            // 总结果
            const summaryDiv = document.createElement('div');
            summaryDiv.className = 'test-section';
            if (allPassed) {
                summaryDiv.innerHTML = `<h2 style="color: green;">✅ 所有测试通过！修复已生效。</h2>`;
            } else {
                summaryDiv.innerHTML = `<h2 style="color: red;">❌ 部分测试失败！请检查修复代码。</h2>`;
            }
            resultsDiv.appendChild(summaryDiv);

            // 显示当前实际时间
            const currentTimeDiv = document.createElement('div');
            currentTimeDiv.className = 'test-section';
            currentTimeDiv.innerHTML = `<h3>当前实际时间</h3><p>${nowCST.toLocaleString()}</p>`;
            resultsDiv.appendChild(currentTimeDiv);
        }

        // 自定义测试
        function runCustomTest() {
            const customTimeInput = document.getElementById('custom-time');
            const timeParts = customTimeInput.value.split(':');
            if (timeParts.length !== 2) {
                alert('请输入有效的时间格式（HH:MM）');
                return;
            }

            const hour = parseInt(timeParts[0]);
            const minute = parseInt(timeParts[1]);
            if (isNaN(hour) || isNaN(minute) || hour < 0 || hour > 23 || minute < 0 || minute > 59) {
                alert('请输入有效的时间（00:00-23:59）');
                return;
            }

            // 创建测试任务
            const testTask = {
                displayThreshold: 2,
                displayThresholdUnit: "hours",
                recurrence: {
                    type: "daily",
                    startTimes: ["10:00", "14:00", "18:00"],
                    duration: 3,
                    durationUnit: "hours"
                }
            };

            // 设置测试时间
            const nowCST = new Date();
            const testTime = new Date(nowCST.getFullYear(), nowCST.getMonth(), nowCST.getDate(), hour, minute, 0, 0);

            // 运行测试
            const result = getTaskStatus(testTask, testTime);
            const customResultDiv = document.getElementById('custom-test-result');
            
            customResultDiv.innerHTML = `<h3>自定义测试结果</h3>`;
            customResultDiv.innerHTML += `<p>测试时间: ${testTime.toLocaleString()}</p>`;
            customResultDiv.innerHTML += `<p>事件状态: ${result.status}</p>`;
            customResultDiv.innerHTML += `<p>时间文本: ${result.timeText}</p>`;
            customResultDiv.innerHTML += `<p>倒计时: ${result.countdownText}</p>`;
            customResultDiv.innerHTML += `<p>开始时间: ${result.startTime.toLocaleString()}</p>`;
            customResultDiv.innerHTML += `<p>结束时间: ${result.endTime.toLocaleString()}</p>`;

            // 检查是否为预期的ongoing状态
            const isOngoing = (hour >= 10 && hour < 13) || (hour >= 14 && hour < 17) || (hour >= 18 && hour < 21);
            if (isOngoing && result.status === "ongoing") {
                customResultDiv.innerHTML += `<p style="color: green; font-weight: bold;">✅ 测试通过！事件正确显示为"正在进行"。</p>`;
            } else if (!isOngoing && result.status !== "ongoing") {
                customResultDiv.innerHTML += `<p style="color: green; font-weight: bold;">✅ 测试通过！事件状态符合预期。</p>`;
            } else {
                customResultDiv.innerHTML += `<p style="color: red; font-weight: bold;">❌ 测试失败！事件状态不符合预期。</p>`;
            }
        }

        // 页面加载完成后执行测试
        window.onload = function() {
            runTests();
        };
    </script>
</head>
<body>
    <h1>全面测试事件显示修复</h1>
    <div class="test-section">
        <h2>批量测试</h2>
        <p>自动运行10个测试场景，验证不同时间段的事件状态显示。</p>
        <button onclick="runTests()">重新运行所有测试</button>
    </div>
    <div class="test-section">
        <h2>自定义测试</h2>
        <p>输入时间进行单个测试：</p>
        <input type="time" id="custom-time" value="12:00">
        <button onclick="runCustomTest()">运行自定义测试</button>
        <div id="custom-test-result" class="test-result"></div>
    </div>
    <div class="test-section">
        <h2>测试结果</h2>
        <div id="test-results"></div>
    </div>
</body>
</html>